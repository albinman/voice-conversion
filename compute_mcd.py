"""
This module calculates the mel-cepstral distortion between synthesized
sampels and their reference samples based on Samuel Broughton's repository
https://github.com/SamuelBroughton/Mel-Cepstral-Distortion.
"""
import os
import librosa
import numpy as np
import math
import csv

alpha=0.65
fft_size=512
mcep_size=34
SAMPLING_RATE = 22050
FRAME_PERIOD = 5.0

# paths to folder of converted samples (syn)
# and folder of real utterances (ref)
syn_parent_path = './voice-conversion/synthesized_samples'
ref_parent_path = './voice-conversion/reference_samples'


def log_spec_dB_dist(x, y):
    log_spec_dB_const = 10.0 / math.log(10.0) * math.sqrt(2.0)
    diff = x - y
    return log_spec_dB_const * math.sqrt(np.inner(diff, diff))


cost_function = log_spec_dB_dist


def compute_mcd(ref, syn):
    min_cost, _ = librosa.sequence.dtw(ref[:, 1:].T, syn[:, 1:].T, metric=cost_function)
    return np.mean(min_cost)/len(ref)


def compute_average_mcd(dir_A, dir_B):
    """
    Compute MCD for pairs of MCEP arrays stored in two folder separately
    :param dir_A: path to folder of synthesized samples as npy arrays
    :param dir_B: path to folder of reference samples as npy arrays
    :return: tuple: average mcd of all sentences, list of mcd for each sentence
    """
    min_cost_tot = 0.0
    frames_tot = 0
    recid_file = os.path.join(dir_A, 'rec_ids.txt')
    rec_id_list = [line.rstrip() for line in (open(recid_file, 'r')).readlines() if not line.rstrip() == '400']
    mcd_per_sentence = []
    for rec_id in rec_id_list:
        # load MCEP vectors
        for file_A in os.listdir(dir_A):
            if file_A.endswith(rec_id+'.npy'):
                for file_B in os.listdir(dir_B):
                    if file_B.endswith(rec_id+'.npy'):
                        # load MCEP vectors
                        A = os.path.join(dir_A, file_A)
                        B = os.path.join(dir_B, file_B)
                        vec_A = np.load(A)
                        ref_frame_no = len(vec_A)
                        vec_B = np.load(B)
                        # dynamic time warping using librosa
                        min_cost, _ = librosa.sequence.dtw(vec_A[:, 1:].T, vec_B[:, 1:].T, metric=cost_function)
                        min_cost = np.mean(min_cost)
                        mcd_per_sentence.append(min_cost/ref_frame_no)
                        min_cost_tot += min_cost
                        frames_tot += ref_frame_no
                        #print('{} & {}: {}'.format(A, B, np.mean(min_cost)/ref_frame_no))
    mean_mcd = min_cost_tot / frames_tot
    #print(mean_mcd)
    return mean_mcd, mcd_per_sentence


def process_batch(ref_parent_path, syn_parent_path):
    """
    Calculate MCDs for all speaker pairs and writes results in a CSV file
    :param ref_parent_path: path to folder of real utterances
    :param syn_parent_path: path to synthesized samples generated by VC model
    :return: None, writes mcd_results.csv
    """
    csv_filepath = './mcd_results.csv'
    with open(csv_filepath, 'w') as csv_file:
        csv_writer = csv.writer(csv_file)
        csv_writer.writerow(['model_name', 'mean_mcd', 'mcd_per_sentence'])

        for model_name in os.listdir(syn_parent_path):
            if not model_name == 'info':
                syn = model_name
                model_components = model_name.split('_')
                ref = model_components[1][:2]+model_components[0][-2:]
                print(syn, ref)
                mean_mcd, mcd_per_sentence = compute_average_mcd(dir_A=os.path.join(ref_parent_path, ref),
                                                                 dir_B=os.path.join(syn_parent_path, syn))
                csv_writer.writerow([model_name, mean_mcd, mcd_per_sentence])


def main():
    process_batch(ref_parent_path, syn_parent_path)


if __name__ == '__main__':
    main()
